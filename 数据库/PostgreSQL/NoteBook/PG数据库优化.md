#### 1、数据表优化

1. 为经常查询的字段建立索引，走索引查询能够显著提高查询速度，因为走索引查询查询匹配的行，而不是扫描整个表。
2. 地理信息格式的数据通常是为**时间建立索引**，为**地理信息字段创建GIST索引**等

#### 2、SQL查询优化

​		在SQL查询方面，常用到的技术有：

1. 使用索引：索引可以极大地提高查询性能，不用扫描整张表。
2. 尽量缩小查询范围：不断精确查询范围。
3. 避免使用通配符等......

#### 3、配置PG数据库

​		在大型数据库中，内存管理是一个非常重要的问题。如何优化内存的使用非常重要：

1. 调整**缓冲区**大小，shared_buffers参数控制着PostgreSQL在共享内存中分配的缓冲区的大小。

    ```sql
    shared_buffers = 16GB
    ```

2. 调整PG在执行排序、哈希和聚合等操作时使用的内存量。默认是4MB，处理大量的数据时可以设置为1GB。

    ```sql
    work_mem = 1GB
    ```

3. 调整PG数据库自带进程如autovacuum垃圾自动回收和其他维护操作时使用的内存量。默认为64MB，可以调整到2GB。

    ```sql
    maintenance_work_mem = 2GB
    ```


#### 4、autoacuum自动垃圾回收

​		在PG数据库中是没有回滚段，旧数据是直接放到原有文件里的，由PG自带的自动垃圾回收实现对旧数据的处理。

在优化垃圾回收方面，有以下两个方面：

1. **调整 max_wal_size 参数**：通过增加这个参数的值，可以增加WAL（Write-Ahead Log）的大小，从而减少垃圾回收的减少。默认值是1GB，但是如果您有很多更新操作，可以将其增加到10GB或更高。例如，以下命令将 max_wal_size 设置为10GB：max_wal_size = 10GB
2. **定期执行VACUUM操作**：VACUUM是一种用于回收未使用空间的命令。在PostgreSQL中，您可以使用自动VACUUM或手动VACUUM来回收未使用的空间。手动执行VACUUM操作可以在需要时立即回收未使用的空间，从而提高性能。

#### 什么是MVCC？

​		Multi version concurrent control(MCC or MVCC)，**解决数据库中读写不能并发的问题**。MVCC的方法就是写数据时，**旧的版本数据并不删除**，并发的读还能读到旧的版本数据。

- 查询和更新、删除、插入操作互相不阻塞
- 当开始一个查询后，读到的数据总是**查询开始时那个时间点的快照**
    - 在查询开始后，发生的变更（即使已提交），这次查询也是看不到的。
    - 一个事务无论运行多长时间，看到数据都是相同的
    - 不同开始时间的事务中相同的查询，返回的数据也可能不同

![](https://cdn.jsdelivr.net/gh/ZGuangJie/GoPicture/golang/202406211508254.png)

##### MVCC实现方法

1. **第一种：**写新数据时，把旧数据移到一个单独的地方，如回滚段中，其他人读数据时，从回滚段中把旧的数据读出来
2. **第二种：**写新数据时，旧数据不删除，而是把新数据插入。

​		PostgreSQL是使用的第二种方法，即旧的数据在数据块中不删除，而Oracle数据库和MySQL中的innodb引擎使用的是第一种方法，即回滚段的方法。PostgreSQL是在数据库表增加了两个系统列：xmin和xmax,用于记录数据行的版本信息。xmin和xmax记录的是事务D，需要我们先学习事务D的相关知识后，再来了解多版本的具体实现。

**记住：PostgreSQL没有回滚段！！！**

- 旧数据是放在**原有数据文件**中的
- 如果放在原有的数据文件中，旧数据越来越多怎么办？
    - 有**自动垃圾回收autovacuum**来做这个事。
- 更新操作中新行的物理位置发生了变化，非更新列的索引是不是也要更新？
    - 通常不会，HOT技术。如果原有的数据块之间有空间，**旧行与新行之间会建一个链接**，索引上仍然指向旧的数据行
- 垃圾回收的代价会不会影响性能？
    - 有很多参数控制这个影响：**vacuum_cost_delay**, **vacuum_cost_limit**

**实现方法**

- 每行上有**xmin（事务id）**和**xmax（删除事务id）**两个系统字段
- 当插入一行数据时，将这行上的xmin设置为当前的事务id,而xmax设置为0
- 当更新一行时，实际上是插入新行，把**旧行上的xmax设置为当前事务id**，**新插入行的xmin设置为当前事务id**，**新行的xmax设置为0**。
- 当删除一行时，把当前行的xmax设置为当前事务id
- 当读到一行时，到commitlog中查询xmin和xmax对应的**事务状态**是否是已提交还是回滚了，就能判断出此行对当前行是否是可见。
-  **autovacuum进程**会把一些不要的旧行清理掉
- **补充：**事务的状态可以去commitlog中查找（这种方式太慢，也有一些复杂的机制），事务状态有以下四种：
    - ![](https://cdn.jsdelivr.net/gh/ZGuangJie/GoPicture/golang/202406211534177.png)

